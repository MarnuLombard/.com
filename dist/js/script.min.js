// version 1.6.0
// http://welcome.totheinter.net/columnizer-jquery-plugin/
// created by: Adam Wulf @adamwulf, adam.wulf@gmail.com

(function($){

 $.fn.columnize = function(options) {


	var defaults = {
		// default width of columns
		width: 400,
		// optional # of columns instead of width
		columns : false,
		// true to build columns once regardless of window resize
		// false to rebuild when content box changes bounds
		buildOnce : false,
		// an object with options if the text should overflow
		// it's container if it can't fit within a specified height
		overflow : false,
		// this function is called after content is columnized
		doneFunc : function(){},
		// if the content should be columnized into a
		// container node other than it's own node
		target : false,
		// re-columnizing when images reload might make things
		// run slow. so flip this to true if it's causing delays
		ignoreImageLoading : true,
		// should columns float left or right
		columnFloat : "left",
		// ensure the last column is never the tallest column
		lastNeverTallest : false,
		// (int) the minimum number of characters to jump when splitting
		// text nodes. smaller numbers will result in higher accuracy
		// column widths, but will take slightly longer
		accuracy : false,
		// don't automatically layout columns, only use manual columnbreak
		manualBreaks : false,
		// previx for all the CSS classes used by this plugin
		// default to empty string for backwards compatibility
		cssClassPrefix : ""
	};
	options = $.extend(defaults, options);

	if(typeof(options.width) == "string"){
		options.width = parseInt(options.width,10);
		if(isNaN(options.width)){
			options.width = defaults.width;
		}
	}

	/**
	 * appending a text node to a <table> will
	 * cause a jquery crash.
	 * so wrap all append() calls and revert to
	 * a simple appendChild() in case it fails
	 */
	function appendSafe($target, $elem){
		try{
			$target.append($elem);
		}catch(e){
			$target[0].appendChild($elem[0]);
		}
	}

    return this.each(function() {
		var $inBox = options.target ? $(options.target) : $(this);
		var maxHeight = $(this).height();
		var $cache = $('<div></div>'); // this is where we'll put the real content
		var lastWidth = 0;
		var columnizing = false;
		var manualBreaks = options.manualBreaks;
		var cssClassPrefix = defaults.cssClassPrefix;
		if(typeof(options.cssClassPrefix) == "string"){
			cssClassPrefix = options.cssClassPrefix;
		}


		var adjustment = 0;

		appendSafe($cache, $(this).contents().clone(true));

		// images loading after dom load
		// can screw up the column heights,
		// so recolumnize after images load
		if(!options.ignoreImageLoading && !options.target){
			if(!$inBox.data("imageLoaded")){
				$inBox.data("imageLoaded", true);
				if($(this).find("img").length > 0){
					// only bother if there are
					// actually images...
					var func = function($inBox,$cache){ return function(){
							if(!$inBox.data("firstImageLoaded")){
								$inBox.data("firstImageLoaded", "true");
								appendSafe($inBox.empty(), $cache.children().clone(true));
								$inBox.columnize(options);
							}
						};
					}($(this), $cache);
					$(this).find("img").one("load", func);
					$(this).find("img").one("abort", func);
					return;
				}
			}
		}

		$inBox.empty();

		columnizeIt();

		if(!options.buildOnce){
			$(window).resize(function() {
				if(!options.buildOnce){
					if($inBox.data("timeout")){
						clearTimeout($inBox.data("timeout"));
					}
					$inBox.data("timeout", setTimeout(columnizeIt, 200));
				}
			});
		}

		function prefixTheClassName(className, withDot){
			var dot = withDot ? "." : "";
			if(cssClassPrefix.length){
				return dot + cssClassPrefix + "-" + className;
			}
			return dot + className;
		}

		/**
		 * this fuction builds as much of a column as it can without
		 * splitting nodes in half. If the last node in the new column
		 * is a text node, then it will try to split that text node. otherwise
		 * it will leave the node in $pullOutHere and return with a height
		 * smaller than targetHeight.
		 *
         * Returns a boolean on whether we did some splitting successfully at a text point
         * (so we know we don't need to split a real element). return false if the caller should
         * split a node if possible to end this column.
		 *
		 * @param putInHere, the jquery node to put elements into for the current column
		 * @param $pullOutHere, the jquery node to pull elements out of (uncolumnized html)
		 * @param $parentColumn, the jquery node for the currently column that's being added to
		 * @param targetHeight, the ideal height for the column, get as close as we can to this height
		 */
		function columnize($putInHere, $pullOutHere, $parentColumn, targetHeight){
			//
			// add as many nodes to the column as we can,
			// but stop once our height is too tall
			while((manualBreaks || $parentColumn.height() < targetHeight) &&
				$pullOutHere[0].childNodes.length){
				var node = $pullOutHere[0].childNodes[0];
				//
				// Because we're not cloning, jquery will actually move the element"
				// http://welcome.totheinter.net/2009/03/19/the-undocumented-life-of-jquerys-append/
				if($(node).find(prefixTheClassName("columnbreak", true)).length){
					//
					// our column is on a column break, so just end here
					return;
				}
				if($(node).hasClass(prefixTheClassName("columnbreak"))){
					//
					// our column is on a column break, so just end here
					return;
				}
				appendSafe($putInHere, $(node));
			}
			if($putInHere[0].childNodes.length === 0) return;

			// now we're too tall, so undo the last one
			var kids = $putInHere[0].childNodes;
			var lastKid = kids[kids.length-1];
			$putInHere[0].removeChild(lastKid);
			var $item = $(lastKid);

			// now lets try to split that last node
			// to fit as much of it as we can into this column
			if($item[0].nodeType == 3){
				// it's a text node, split it up
				var oText = $item[0].nodeValue;
				var counter2 = options.width / 18;
				if(options.accuracy)
				counter2 = options.accuracy;
				var columnText;
				var latestTextNode = null;
				while($parentColumn.height() < targetHeight && oText.length){
					//
					// it's been brought up that this won't work for chinese
					// or other languages that don't have the same use of whitespace
					// as english. This will need to be updated in the future
					// to better handle non-english languages.
					//
					// https://github.com/adamwulf/Columnizer-jQuery-Plugin/issues/124
					var indexOfSpace = oText.indexOf(' ', counter2);
					if (indexOfSpace != -1) {
						columnText = oText.substring(0, indexOfSpace);
					} else {
						columnText = oText;
					}
					latestTextNode = document.createTextNode(columnText);
					appendSafe($putInHere, $(latestTextNode));

					if(oText.length > counter2 && indexOfSpace != -1){
						oText = oText.substring(indexOfSpace);
					}else{
						oText = "";
					}
				}
				if($parentColumn.height() >= targetHeight && latestTextNode !== null){
					// too tall :(
					$putInHere[0].removeChild(latestTextNode);
					oText = latestTextNode.nodeValue + oText;
				}
				if(oText.length){
					$item[0].nodeValue = oText;
				}else{
					return false; // we ate the whole text node, move on to the next node
				}
			}

			if($pullOutHere.contents().length){
				$pullOutHere.prepend($item);
			}else{
				appendSafe($pullOutHere, $item);
			}

			return $item[0].nodeType == 3;
		}

		/**
		 * Split up an element, which is more complex than splitting text. We need to create
		 * two copies of the element with it's contents divided between each
		 */
		function split($putInHere, $pullOutHere, $parentColumn, targetHeight){
			if($putInHere.contents(":last").find(prefixTheClassName("columnbreak", true)).length){
				//
				// our column is on a column break, so just end here
				return;
			}
			if($putInHere.contents(":last").hasClass(prefixTheClassName("columnbreak"))){
				//
				// our column is on a column break, so just end here
				return;
			}
			if($pullOutHere.contents().length){
				var $cloneMe = $pullOutHere.contents(":first");
				//
				// make sure we're splitting an element
				if( typeof $cloneMe.get(0) == 'undefined' || $cloneMe.get(0).nodeType != 1 ) return;

				//
				// clone the node with all data and events
				var $clone = $cloneMe.clone(true);
				//
				// need to support both .prop and .attr if .prop doesn't exist.
				// this is for backwards compatibility with older versions of jquery.
				if($cloneMe.hasClass(prefixTheClassName("columnbreak"))){
					//
					// ok, we have a columnbreak, so add it into
					// the column and exit
					appendSafe($putInHere, $clone);
					$cloneMe.remove();
				}else if (manualBreaks){
					// keep adding until we hit a manual break
					appendSafe($putInHere, $clone);
					$cloneMe.remove();
				}else if($clone.get(0).nodeType == 1 && !$clone.hasClass(prefixTheClassName("dontend"))){
					appendSafe($putInHere, $clone);
					if($clone.is("img") && $parentColumn.height() < targetHeight + 20){
						//
						// we can't split an img in half, so just add it
						// to the column and remove it from the pullOutHere section
						$cloneMe.remove();
					}else if($cloneMe.hasClass(prefixTheClassName("dontsplit")) && $parentColumn.height() < targetHeight + 20){
						//
						// pretty close fit, and we're not allowed to split it, so just
						// add it to the column, remove from pullOutHere, and be done
						$cloneMe.remove();
					}else if($clone.is("img") || $cloneMe.hasClass(prefixTheClassName("dontsplit"))){
						//
						// it's either an image that's too tall, or an unsplittable node
						// that's too tall. leave it in the pullOutHere and we'll add it to the
						// next column
						$clone.remove();
					}else{
						//
						// ok, we're allowed to split the node in half, so empty out
						// the node in the column we're building, and start splitting
						// it in half, leaving some of it in pullOutHere
						$clone.empty();
						if(!columnize($clone, $cloneMe, $parentColumn, targetHeight)){
							// this node may still have non-text nodes to split
							// add the split class and then recur
							$cloneMe.addClass(prefixTheClassName("split"));

							//if this node was ol element, the child should continue the number ordering
							if($cloneMe.get(0).tagName == 'OL'){
								var startWith = $clone.get(0).childElementCount + $clone.get(0).start;
								$cloneMe.attr('start',startWith+1);
							}

							if($cloneMe.children().length){
								split($clone, $cloneMe, $parentColumn, targetHeight);
							}
						}else{
							// this node only has text node children left, add the
							// split class and move on.
							$cloneMe.addClass(prefixTheClassName("split"));
						}
						if($clone.get(0).childNodes.length === 0){
							// it was split, but nothing is in it :(
							$clone.remove();
							$cloneMe.removeClass(prefixTheClassName("split"));
						}
					}
				}
			}
		}


		function singleColumnizeIt() {
			if ($inBox.data("columnized") && $inBox.children().length == 1) {
				return;
			}
			$inBox.data("columnized", true);
			$inBox.data("columnizing", true);

			$inBox.empty();
			$inBox.append($("<div class='"
				+ prefixTheClassName("first") + " "
				+ prefixTheClassName("last") + " "
				+ prefixTheClassName("column") + " "
				+ "' style='width:100%; float: " + options.columnFloat + ";'></div>")); //"
			$col = $inBox.children().eq($inBox.children().length-1);
			$destroyable = $cache.clone(true);
			if(options.overflow){
				targetHeight = options.overflow.height;
				columnize($col, $destroyable, $col, targetHeight);
				// make sure that the last item in the column isn't a "dontend"
				if(!$destroyable.contents().find(":first-child").hasClass(prefixTheClassName("dontend"))){
					split($col, $destroyable, $col, targetHeight);
				}

				while($col.contents(":last").length && checkDontEndColumn($col.contents(":last").get(0))){
					var $lastKid = $col.contents(":last");
					$lastKid.remove();
					$destroyable.prepend($lastKid);
				}

				var html = "";
				var div = document.createElement('DIV');
				while($destroyable[0].childNodes.length > 0){
					var kid = $destroyable[0].childNodes[0];
					if(kid.attributes){
						for(var i=0;i<kid.attributes.length;i++){
							if(kid.attributes[i].nodeName.indexOf("jQuery") === 0){
								kid.removeAttribute(kid.attributes[i].nodeName);
							}
						}
					}
					div.innerHTML = "";
					div.appendChild($destroyable[0].childNodes[0]);
					html += div.innerHTML;
				}
				var overflow = $(options.overflow.id)[0];
				overflow.innerHTML = html;

			}else{
				appendSafe($col, $destroyable.contents());
			}
			$inBox.data("columnizing", false);

			if(options.overflow && options.overflow.doneFunc){
				options.overflow.doneFunc();
			}

		}

		/**
		 * returns true if the input dom node
		 * should not end a column.
		 * returns false otherwise
		 */
		function checkDontEndColumn(dom){
			if(dom.nodeType == 3){
				// text node. ensure that the text
				// is not 100% whitespace
				if(/^\s+$/.test(dom.nodeValue)){
						//
						// ok, it's 100% whitespace,
						// so we should return checkDontEndColumn
						// of the inputs previousSibling
						if(!dom.previousSibling) return false;
					return checkDontEndColumn(dom.previousSibling);
				}
				return false;
			}
			if(dom.nodeType != 1) return false;
			if($(dom).hasClass(prefixTheClassName("dontend"))) return true;
			if(dom.childNodes.length === 0) return false;
			return checkDontEndColumn(dom.childNodes[dom.childNodes.length-1]);
		}

		function columnizeIt() {
			//reset adjustment var
			adjustment = 0;
			if(lastWidth == $inBox.width()) return;
			lastWidth = $inBox.width();

			var numCols = Math.round($inBox.width() / options.width);
			var optionWidth = options.width;
			var optionHeight = options.height;
			if(options.columns) numCols = options.columns;
			if(manualBreaks){
				numCols = $cache.find(prefixTheClassName("columnbreak", true)).length + 1;
				optionWidth = false;
			}

//			if ($inBox.data("columnized") && numCols == $inBox.children().length) {
//				return;
//			}
			if(numCols <= 1){
				return singleColumnizeIt();
			}
			if($inBox.data("columnizing")) return;
			$inBox.data("columnized", true);
			$inBox.data("columnizing", true);

			$inBox.empty();
			$inBox.append($("<div style='width:" + (Math.floor(100 / numCols))+ "%; float: " + options.columnFloat + ";'></div>")); //"
			$col = $inBox.children(":last");
			appendSafe($col, $cache.clone());
			maxHeight = $col.height();
			$inBox.empty();

			var targetHeight = maxHeight / numCols;
			var firstTime = true;
			var maxLoops = 3;
			var scrollHorizontally = false;
			if(options.overflow){
				maxLoops = 1;
				targetHeight = options.overflow.height;
			}else if(optionHeight && optionWidth){
				maxLoops = 1;
				targetHeight = optionHeight;
				scrollHorizontally = true;
			}

			//
			// We loop as we try and workout a good height to use. We know it initially as an average
			// but if the last column is higher than the first ones (which can happen, depending on split
			// points) we need to raise 'adjustment'. We try this over a few iterations until we're 'solid'.
			//
			// also, lets hard code the max loops to 20. that's /a lot/ of loops for columnizer,
			// and should keep run aways in check. if somehow someone has content combined with
			// options that would cause an infinite loop, then this'll definitely stop it.
			for(var loopCount=0;loopCount<maxLoops && loopCount<20;loopCount++){
				$inBox.empty();
				var $destroyable, className, $col, $lastKid;
				try{
					$destroyable = $cache.clone(true);
				}catch(e){
					// jquery in ie6 can't clone with true
					$destroyable = $cache.clone();
				}
				$destroyable.css("visibility", "hidden");
				// create the columns
				for (var i = 0; i < numCols; i++) {
					/* create column */
					className = (i === 0) ? prefixTheClassName("first") : "";
					className += " " + prefixTheClassName("column");
					className = (i == numCols - 1) ? (prefixTheClassName("last") + " " + className) : className;
					$inBox.append($("<div class='" + className + "' style='width:" + (Math.floor(100 / numCols))+ "%; float: " + options.columnFloat + ";'></div>")); //"
				}

				// fill all but the last column (unless overflowing)
				i = 0;
				while(i < numCols - (options.overflow ? 0 : 1) || scrollHorizontally && $destroyable.contents().length){
					if($inBox.children().length <= i){
						// we ran out of columns, make another
						$inBox.append($("<div class='" + className + "' style='width:" + (Math.floor(100 / numCols))+ "%; float: " + options.columnFloat + ";'></div>")); //"
					}
					$col = $inBox.children().eq(i);
					if(scrollHorizontally){
						$col.width(optionWidth + "px");
					}
					columnize($col, $destroyable, $col, targetHeight);
					// make sure that the last item in the column isn't a "dontend"
					split($col, $destroyable, $col, targetHeight);

					while($col.contents(":last").length && checkDontEndColumn($col.contents(":last").get(0))){
						$lastKid = $col.contents(":last");
						$lastKid.remove();
						$destroyable.prepend($lastKid);
					}
					i++;

					//
					// https://github.com/adamwulf/Columnizer-jQuery-Plugin/issues/47
					//
					// check for infinite loop.
					//
					// this could happen when a dontsplit or dontend item is taller than the column
					// we're trying to build, and its never actually added to a column.
					//
					// this results in empty columns being added with the dontsplit item
					// perpetually waiting to get put into a column. lets force the issue here
					if($col.contents().length === 0 && $destroyable.contents().length){
						//
						// ok, we're building zero content columns. this'll happen forever
						// since nothing can ever get taken out of destroyable.
						//
						// to fix, lets put 1 item from destroyable into the empty column
						// before we iterate
						$col.append($destroyable.contents(":first"));
					}else if(i == numCols - (options.overflow ? 0 : 1) && !options.overflow){
						//
						// ok, we're about to exit the while loop because we're done with all
						// columns except the last column.
						//
						// if $destroyable still has columnbreak nodes in it, then we need to keep
						// looping and creating more columns.
						if($destroyable.find(prefixTheClassName("columnbreak", true)).length){
							numCols ++;
						}
					}
				}
				if(options.overflow && !scrollHorizontally){
					var IE6 = false /*@cc_on || @_jscript_version < 5.7 @*/;
					var IE7 = (document.all) && (navigator.appVersion.indexOf("MSIE 7.") != -1);
					if(IE6 || IE7){
						var html = "";
						var div = document.createElement('DIV');
						while($destroyable[0].childNodes.length > 0){
							var kid = $destroyable[0].childNodes[0];
							for(i=0;i<kid.attributes.length;i++){
								if(kid.attributes[i].nodeName.indexOf("jQuery") === 0){
									kid.removeAttribute(kid.attributes[i].nodeName);
								}
							}
							div.innerHTML = "";
							div.appendChild($destroyable[0].childNodes[0]);
							html += div.innerHTML;
						}
						var overflow = $(options.overflow.id)[0];
						overflow.innerHTML = html;
					}else{
						$(options.overflow.id).empty().append($destroyable.contents().clone(true));
					}
				}else if(!scrollHorizontally){
					// the last column in the series
					$col = $inBox.children().eq($inBox.children().length-1);
					$destroyable.contents().each( function() {
						$col.append( $(this) );
					});
					var afterH = $col.height();
					var diff = afterH - targetHeight;
					var totalH = 0;
					var min = 10000000;
					var max = 0;
					var lastIsMax = false;
					var numberOfColumnsThatDontEndInAColumnBreak = 0;
					$inBox.children().each(function($inBox){ return function($item){
						var $col = $inBox.children().eq($item);
						var endsInBreak = $col.children(":last").find(prefixTheClassName("columnbreak", true)).length;
						if(!endsInBreak){
							var h = $col.height();
							lastIsMax = false;
							totalH += h;
							if(h > max) {
								max = h;
								lastIsMax = true;
							}
							if(h < min) min = h;
							numberOfColumnsThatDontEndInAColumnBreak++;
						}
					};
				}($inBox));

					var avgH = totalH / numberOfColumnsThatDontEndInAColumnBreak;
					if(totalH === 0){
						//
						// all columns end in a column break,
						// so we're done here
						loopCount = maxLoops;
					}else if(options.lastNeverTallest && lastIsMax){
						// the last column is the tallest
						// so allow columns to be taller
						// and retry
						//
						// hopefully this'll mean more content fits into
						// earlier columns, so that the last column
						// can be shorter than the rest
						adjustment += 5;

						targetHeight = targetHeight + 30;
						if(loopCount == maxLoops-1) maxLoops++;
					}else if(max - min > 30){
						// too much variation, try again
						targetHeight = avgH + 30;
					}else if(Math.abs(avgH-targetHeight) > 20){
						// too much variation, try again
						targetHeight = avgH;
					}else {
						// solid, we're done
						loopCount = maxLoops;
					}
				}else{
					// it's scrolling horizontally, fix the width/classes of the columns
					$inBox.children().each(function(i){
						$col = $inBox.children().eq(i);
						$col.width(optionWidth + "px");
						if(i === 0){
							$col.addClass(prefixTheClassName("first"));
						}else if(i==$inBox.children().length-1){
							$col.addClass(prefixTheClassName("last"));
						}else{
							$col.removeClass(prefixTheClassName("first"));
							$col.removeClass(prefixTheClassName("last"));
						}
					});
					$inBox.width($inBox.children().length * optionWidth + "px");
				}
				$inBox.append($("<br style='clear:both;'>"));
			}
			$inBox.find(prefixTheClassName("column", true)).find(":first" + prefixTheClassName("removeiffirst", true)).remove();
			$inBox.find(prefixTheClassName("column", true)).find(':last' + prefixTheClassName("removeiflast", true)).remove();
			$inBox.find(prefixTheClassName("split", true)).find(":first" + prefixTheClassName("removeiffirst", true)).remove();
			$inBox.find(prefixTheClassName("split", true)).find(':last' + prefixTheClassName("removeiflast", true)).remove();
			$inBox.data("columnizing", false);

			if(options.overflow){
				options.overflow.doneFunc();
			}
			options.doneFunc();
		}
    });
 };
})(jQuery);

/*!
 * fluidBox - jQuery Plugin
 * version: 1.0
 * @requires jQuery v1.8 or later
 *
 * Copyright (c) 2012 - 2013 Maarten de Boer - info@maartendeboer.net
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

(function($) {
	"use strict";

	$(function() {
		var F = $.fluidbox = {

			/** Working set */
			_currentCollection: {},
			_currentIndex: null,
			_currentOptions: {},
			_instance: {},

			/** States */
			_isLoading: false,
			_isOpening: false,
			_isClosing: false,
			_isAnimated: false,
			_isDraggable: false,

			/** Support libs */
			_hasModernizr: false,
			_hasHammer: false,

			/** Quick access variables for layout */
			_overlay: {},
			_viewport: {},
			_outer: {},
			_inner: {},
			_loading: {},
			_title: {},

			/** Animation classes */
			_animClasses: "animated flash bounce shake tada swing wobble wiggle pulse flip flipInX flipOutX flipInY flipOutY fadeIn fadeInUp fadeInDown fadeInLeft fadeInRight fadeInUpBig fadeInDownBig fadeInLeftBig fadeInRightBig fadeOut fadeOutUp fadeOutDown fadeOutLeft fadeOutRight fadeOutUpBig fadeOutDownBig fadeOutLeftBig fadeOutRightBig bounceIn bounceInDown bounceInUp bounceInLeft bounceInRight bounceOut bounceOutDown bounceOutUp bounceOutLeft bounceOutRight rotateIn rotateInDownLeft rotateInDownRight rotateInUpLeft rotateInUpRight rotateOut rotateOutDownLeft rotateOutDownRight rotateOutUpLeft rotateOutUpRight lightSpeedIn lightSpeedOut hinge rollIn rollOut",

			/** Animation end events */
			_transEndEventNames: 'webkitAnimationEnd animationend oanimationend MSAnimationEnd',

			/** Default options */
			defaults: {
				resize: true,
				preload: true,
				touch: true,
				animated: true,
				padding: 50,
				templates: {
					inner: '<div id="fluidbox-inner"></div>',
					outer: '<div id="fluidbox-outer"></div>',
					overlay: '<div id="fluidbox-overlay"></div>',
					loading: '<div id="fluidbox-loading"></div>',
					title: '<div id="fluidbox-title"></div>',
					buttons: {
						close: '<div id="fluidbox-btn-close"></div>',
						next: '<div id="fluidbox-btn-next"></div>',
						prev: '<div id="fluidbox-btn-prev"></div>'
					}
				},
				positions: {
					buttons: {
						close: 'outer',
						next: 'inner',
						prev: 'inner'
					},
					title: 'inner'
				},
				keys: {
					next: [39, 40],
					prev: [37, 38],
					close: [27]
				},
				animations: {
					open: 'fadeIn',
					close: 'fadeOut',
					next: {
						'in': 'fadeInRight',
						'out': 'fadeOutLeft'
					},
					prev: {
						'in': 'fadeInLeft',
						'out': 'fadeOutRight'
					}
				}
			},

			/** Injects necessary html templates for the overlay */
			_createOverlay: function() {
				$(F._instance).triggerHandler("fluidboxBeforeCreate");

				// Outer (containing inner)
				if($('#fluidbox-outer').length === 0) {
					$('body').append(F._currentOptions.templates.outer);
					$('#fluidbox-outer').html(F._currentOptions.templates.inner);
				}

				// Overlay
				if($('#fluidbox-overlay').length === 0) {
					$('body').append(F._currentOptions.templates.overlay);
				}

				// Loading
				if($('#fluidbox-loading').length === 0) {
					$('body').append(F._currentOptions.templates.loading);
				}

				// Title
				if($('#fluidbox-title').length === 0 && F._currentOptions.positions.title !== false) {
					$('#fluidbox-'+ F._currentOptions.positions.title).append(F._currentOptions.templates.title);
				}

				// Navigation buttons
				if(F._currentOptions.positions.buttons.close !== false && $('#fluidbox-btn-close').length === 0) {
					$('#fluidbox-'+ F._currentOptions.positions.buttons.close).append(F._currentOptions.templates.buttons.close);
				}

				if(F._currentCollection.length > 1) {
					if(F._currentOptions.positions.buttons.next !== false && $('#fluidbox-btn-next').length === 0) {
						$('#fluidbox-'+ F._currentOptions.positions.buttons.next).append(F._currentOptions.templates.buttons.next);
					}
					if(F._currentOptions.positions.buttons.prev !== false && $('#fluidbox-btn-prev').length === 0) {
						$('#fluidbox-'+ F._currentOptions.positions.buttons.prev).append(F._currentOptions.templates.buttons.prev);
					}
				}

				// Helper vars
				F._overlay = $('#fluidbox-overlay');
				F._outer = $('#fluidbox-outer');
				F._inner = $('#fluidbox-inner');
				F._loading = $('#fluidbox-loading');
				F._title = $('#fluidbox-title');

				// Set helper CSS classes
				if(F._isTouch) {
					F._outer.addClass('touch');
				}

				$(F._instance).triggerHandler("fluidboxAfterCreate");
			},

			/** Clean up bound events */
			_unbindEvents: function() {
				// Unbind window events
				$(document).unbind('keydown.fluidbox');
				$(window).unbind('resize.fluidbox');

				// Unbind overlay
				F._overlay.unbind('click');

				// Unbind navigation buttons
				$('#fluidbox-btn-close').unbind('click');
				$('#fluidbox-btn-next').unbind('click');
				$('#fluidbox-btn-prev').unbind('click');
			},

			/** Bind events */
			_bindEvents: function() {
				$(F._instance).triggerHandler("fluidboxBeforeBind");

				// Key events
				$(document).bind('keydown.fluidbox', function(e) {
					if (!e.ctrlKey && !e.altKey && !e.shiftKey && !e.metaKey) {
						if ($.inArray(e.which, F._currentOptions.keys.close) > -1) {
							F.close();
							e.preventDefault();
						} else if (F._currentCollection.length > 1 && $.inArray(e.which, F._currentOptions.keys.next) > -1) {
							F.next();
							e.preventDefault();
						} else if (F._currentCollection.length > 1 && $.inArray(e.which, F._currentOptions.keys.prev) > -1) {
							F.prev();
							e.preventDefault();
						}
					}
				});

				// Overlay
				F._overlay.click(function() { F.close(); });

				// Buttons
				$('#fluidbox-btn-close').click(function() { F.close(); });
				$('#fluidbox-btn-next').click(function() { F.next(); });
				$('#fluidbox-btn-prev').click(function() { F.prev(); });

				// Scale to full-size and enable dragging
				if(!F._isTouch) {
					F._outer.dblclick(function() {
						if(F._isDraggable === true) {
							F._isDraggable = false;
						} else {
							F._isDraggable = true;
						}

						F.resize();
					});
				}

				// Smart resize
				if(F._currentOptions.resize) {
					$(window).bind("resize.fluidbox", F.resize);
				}

				// Animation events
				if(F._isAnimated !== false) {
					F._bindAnimationEvents();
				}

				// Touch events
				if(F._isTouch) {
					F._bindTouchEvents();
				}

				$(F._instance).triggerHandler("fluidboxAfterBind");
			},

			/** Bind CSS3 animation events */
			_bindAnimationEvents: function() {
				if(F._isAnimated === false) {
					return;
				}

				// Animation completed event
				$(document).bind(F._transEndEventNames, function(e) {
					$(e.target).removeClass(F._animClasses).removeClass('opening closing');

					// Loading
					if($(e.target).is(F._loading)) {
						if(!F._isLoading) {
							F._loading.hide();
						}
					}

					// Overlay
					if($(e.target).is(F._overlay)) {
						if(F._isClosing) {
							F._overlay.remove();
							F._inner.remove();
							F._outer.remove();
							F._loading.remove();

							$('body').css({ overflow: '' });

							$(document).unbind(F._transEndEventNames);
						}
					}

					// Outer
					if($(e.target).is(F._outer)) {
						if(F._isClosing) {
							F._outer.remove();
						}
					}

					// Outer ghost (out-animation ghost)
					if($(e.target).hasClass('fluidbox-outer-ghost')) {
						$(e.target).remove();
					}
				});
			},

			/** Bind touch events */
			_bindTouchEvents: function() {
				F._outer.hammer({
					drag: true,
					transform: true,
					swipe: true,
					tap: true,
					hold: false
				});

				// Drag
				F._outer.bind('dragstart', function(e) {
					e.preventDefault();
					F._outer.data('currentX', parseInt(F._outer.css('left'), 10));
					F._outer.data('currentY', parseInt(F._outer.css('top'), 10));
				});

				F._outer.bind('drag', function(e) {
					if(F._isDraggable) {
						e.preventDefault();

						F._outer.css({
							'left': Math.round(F._outer.data('currentX') + e.gesture.deltaX),
							'top':  Math.round(F._outer.data('currentY') + e.gesture.deltaY)
						});
					}
				});

				F._outer.bind('dragend', function(e) {
					e.preventDefault();
					F._outer.removeData('currentX');
					F._outer.removeData('currentY');
				});

				// Double tap (return to normal size)
				F._outer.bind('doubletap', function(e) {
					F._isDraggable = !F._isDraggable;
					F.resize();
				});

				// Transform (pinch zoom)
				F._outer.bind('transformstart', function(e) {
					F._outer.data('currentX', parseInt(F._outer.css('left'), 10));
					F._outer.data('currentY', parseInt(F._outer.css('top'), 10));
					F._outer.data('currentWidth', F._outer.width());
					F._outer.data('currentHeight', F._outer.height());
					F._isDraggable = true;
				});

				F._outer.bind('transform', function(e) {
					var newWidth = Math.round(F._outer.data('currentWidth') * e.gesture.scale),
						newHeight = Math.round(F._outer.data('currentHeight') * e.gesture.scale);

					F._outer.css({
						'width': newWidth,
						'left': Math.round(F._outer.data('currentX') + ((F._outer.data('currentWidth') - newWidth) / 2) + e.gesture.deltaX),
						'top': Math.round(F._outer.data('currentY') + ((F._outer.data('currentHeight') - newHeight) / 2) + e.gesture.deltaY)
					});
				});

				F._outer.bind('transformend', function(e) {
					F._outer.removeData('currentWidth');
					F._outer.removeData('currentX');
					F._outer.removeData('currentY');
				});

				// Swipe
				F._outer.bind('swipe', function(e) {
					if(!F._isDraggable) {
						if(e.gesture.direction === "left") {
							F.next();
						}
						else if(e.gesture.direction === "right") {
							F.prev();
						}
					}
				});
			},

			/**
			 * Show or hide loading animation
			 * @param bool loading Set true if loading (show), false for not loading (hide)
			 */
			_showLoading: function(loading) {
				F._isLoading = loading;
				F._loading.removeClass(F._animClasses);

				if(F._isLoading) {
					if(F._isAnimated !== false) {
						F._loading.removeClass(F._animClasses).addClass('animated fadeIn');
						F._loading.show();
					} else {
						F._loading.show();
					}
				} else {
					if(F._isAnimated !== false) {
						F._loading.removeClass(F._animClasses).addClass('animated fadeOut');
					} else {
						F._loading.hide();
					}
				}
			},

			/** Preload collection */
			_preloadCollection: function() {
				var i = 0, img;
				for(i = 0; i < F._currentCollection.length; i = i + 1) {
					img = new Image();
					img.src = $(F._currentCollection[i]).attr('href');
				}
			},

			/**
			 * Initialize and show Fluidbox overlay
			 * @constructs
			 */
			open: function(collection, options, instance) {
				F._currentCollection = collection;
				F._instance = instance;

				// Merge options with defaults
				F._currentOptions = $.extend(true, {}, F.defaults, options);
				F._currentIndex = F._currentOptions.index;

				// Set opening / Closing
				F._isOpening = true;
				F._isClosing = false;

				// Check support libs
				F._hasHammer = typeof Hammer === 'function';
				F._hasModernizr = typeof Modernizr === 'function';

				// Check touch support and option
				F._isTouch = F._currentOptions.touch;
				if(F._isTouch && (!F._hasHammer || (F._hasModernizr && !Modernizr.touch))) {
					F._isTouch = false;
					// console.log('Touch support not detected or not available (missing hammer.js?), touch disabled.');
				}

				// Check animation support
				F._isAnimated = F._currentOptions.animated;
				if(F._isAnimated && F._hasModernizr && !Modernizr.csstransitions) {
					F._isAnimated = false;
					// console.log('CSS3 transition support not detected or not available, animations disabled.');
				}

				var fluidboxBeforeOpenEvent = $.Event('fluidboxBeforeOpen');
				$(F._instance).triggerHandler(fluidboxBeforeOpenEvent);

				if(fluidboxBeforeOpenEvent.isDefaultPrevented()) {
					return;
				}

				// Add overlay
				F._createOverlay();

				// Show overlay
				if(F._isAnimated !== false) {
					F._overlay.removeClass(F._animClasses).addClass('animated fadeIn opening');
					F._overlay.show();
				} else {
					F._overlay.show();
				}

				// Save current scroll position (firefox 'unwanted feature')
				var scrollX = document.body.scrollLeft + document.documentElement.scrollLeft,
					scrollY = document.body.scrollTop + document.documentElement.scrollTop;

				// Disable overflow on HTML
				$('body').css({ overflow: 'hidden' });

				// Restore scroll position
				window.scrollTo(scrollX, scrollY);

				// Show image
				F.show(F._currentIndex, 'open');

				// Bind events
				F._bindEvents();

				// Preload
				if(F._currentOptions.preload) {
					F._preloadCollection();
				}

				$(F._instance).triggerHandler("fluidboxAfterOpen");
			},

			/** Close overlay and unbind events */
			close: function() {
				$(F._instance).triggerHandler("fluidboxBeforeClose");

				// Set closing
				F._isClosing = true;

				// Unset draggable
				F._isDraggable = false;

				// Animate overlay and loading image
				if(F._isAnimated !== false) {
					F._overlay.removeClass(F._animClasses).addClass('animated fadeOut closing');
				} else {
					F._overlay.hide();
				}

				// Animate image or loading image
				if(F._isLoading === false) {
					if(F._isAnimated !== false) {
						F._outer.removeClass(F._animClasses).addClass('animated ' + $(F._outer).data('animation').close + ' closing');
					} else {
						F._outer.hide();
					}
				}
				else {
					F._showLoading(false);
					F._outer.hide();
				}

				F._unbindEvents();

				$(F._instance).triggerHandler("fluidboxAfterClose");
			},

			/**
			 * Show next image in collection (if available)
			 */
			next: function() {
				if(F._currentCollection.length <= 1 || F._isDraggable || F._isLoading) {
					return;
				}

				F.show(F._currentIndex === F._currentCollection.length - 1 ? 0 : F._currentIndex + 1, 'next');
			},

			/**
			 * Show previous image in collection (if available)
			 */
			prev: function() {
				if(F._currentCollection.length <= 1 || F._isDraggable || F._isLoading) {
					return;
				}

				F.show(F._currentIndex === 0 ? F._currentCollection.length - 1 : F._currentIndex - 1, 'prev');
			},

			/**
			 * Show image by index in collection (if available else show first image)
			 * @param int index Index of image to show from collection
			 * @param string direction Optional direction parameter (next | prev | open)
			 */
			show: function(index, direction) {
                if(F._isLoading) {
                    return;
                }

				if(index === 'undefined' || index < 0 || index > F._currentCollection.length) {
					index = 0;
				}

				// Determine direction
				if(!direction) {
					if(index > F._currentIndex || index < F._currentIndex) {
						direction = index > F._currentIndex ? 'next' : 'prev';
					}
					else {
						direction = 'open';
					}
				}

				// Set current index
				F._currentIndex = index;

				// Set variables
				var currentElement = F._currentCollection[index],
					currentImage = new Image(),
					oldOuter = $(F._outer).clone(true);

				// Fade out previous item
				if(direction !== 'open' && !F._isLoading) {
					$(F._instance).triggerHandler("fluidboxBeforeHide");

					$(F._outer).removeClass(F._animClasses);
					$(F._outer).hide();

					$(oldOuter).removeAttr('id');
					$(oldOuter).addClass('fluidbox-outer-ghost');
					$(oldOuter).removeClass(F._animClasses);

					$('body').append(oldOuter);

					// Animate
					if(F._isAnimated !== false) {
						if(direction === 'prev') {
							$(oldOuter).addClass('animated ' + $(oldOuter).data('animation').prev.out);
						}
						else if(direction === 'next') {
							$(oldOuter).addClass('animated ' + $(oldOuter).data('animation').next.out);
						}

						$(oldOuter).show();
					} else {
						$(oldOuter).remove();
					}

					$(F._instance).triggerHandler("fluidboxAfterHide");
				}

				// Reset title
				F._title.replaceWith(F._currentOptions.templates.title);
				F._title = $('#fluidbox-title');

				// Reset inner body
				F._inner.children('img').first().remove();

				// Preload image and show when loaded
				currentImage.onload = function() {

					// Set current image data
					var eventData = { index: index, target: currentElement, direction: direction, image: this, title: $(currentElement).attr('title'), animation: $.extend(true, {}, F._currentOptions.animations, $(currentElement).data('animation')) };

					// Trigger callback
					$(F._instance).triggerHandler("fluidboxBeforeShow", eventData);

					// Set animation options for current item
					$(F._outer).data('animation', $.extend(true, {}, F.defaults.animations, eventData.animation));

					// Replace image and animate
					F._inner.append('<img src="'+$(currentElement).attr('href')+'" width="'+this.width+'" height="'+this.height+'" />');

					// Set title
					F._title.append(eventData.title);

					// Animate
					if(F._isAnimated !== false) {
						if(direction === 'open') {
							F._outer.removeClass(F._animClasses).addClass('animated ' + $(F._outer).data('animation').open + ' opening');
						}
						else if(direction === 'prev') {
							F._outer.removeClass(F._animClasses).addClass('animated ' + $(F._outer).data('animation').prev['in']);
						}
						else if(direction === 'next') {
							F._outer.removeClass(F._animClasses).addClass('animated ' + $(F._outer).data('animation').next['in']);
						}

						F._outer.show();
					} else {
						F._outer.show();
					}

					// Hide loading
					F._showLoading(false);

					// Resize image
					if(F._currentOptions.resize) {
						F.resize();
					}

					$(F._instance).triggerHandler("fluidboxAfterShow", eventData);
				};

				currentImage.src = $(currentElement).attr('href');

				// Show loading indicator
				F._showLoading(true);
			},

			/** Resize the overlay */
			resize: function() {
				var origWidth = 0, origHeight = 0,
					winWidth = 0, winHeight = 0,
					vpWidth = 0, vpHeight = 0,
					newWidth = 0, newHeight = 0,
					iRatio = 0;

				origWidth = $(F._inner).children('img').attr('width');
				origHeight = $(F._inner).children('img').attr('height');

				winWidth = $(window).width();
				winHeight = $(window).height();

				vpWidth = winWidth - F._currentOptions.padding;
				vpHeight = winHeight - F._currentOptions.padding;

				if((origWidth > vpWidth || origHeight > vpHeight) && !F._isDraggable) {
					iRatio = Math.min(vpWidth / origWidth, vpHeight / origHeight);
					newWidth = Math.round((origWidth * iRatio));
					newHeight = Math.round((origHeight * iRatio));
					F._outer.css({
						'width': newWidth,
						'left': Math.round((F._currentOptions.padding / 2) + ((vpWidth - newWidth) / 2)),
						'top': Math.round((F._currentOptions.padding / 2) + ((vpHeight - newHeight) / 2))
					});
				} else {
					F._outer.css({
						'width': origWidth,
						'left': Math.round((winWidth - origWidth) / 2),
						'top': Math.round((winHeight - origHeight) / 2)
					});
				}
			}
		};

		$.fn.fluidbox = function(options) {
			var that = $(this);
			options = options || {};

			this.click(function(e) {
				e.preventDefault();

				var collection = [ this ];

				// Filter current collection on "rel" attribute
				if($(this).attr('rel')) {
					collection = that.filter('[rel="'+ $(this).attr('rel') +'"]');
					// Set opening index
					options.index = collection.index(this);
				} else {
					options.index = 0;
				}

				$.fluidbox.open(collection, options, $(that));
			});

			return $(this);
		};

	});
})(jQuery);

/*
* MIXITUP - A CSS3 and JQuery Filter & Sort Plugin
* Version: 1.5.5
* License: Creative Commons Attribution-NoDerivs 3.0 Unported - CC BY-ND 3.0
* http://creativecommons.org/licenses/by-nd/3.0/
* This software may be used freely on commercial and non-commercial projects with attribution to the author/copyright holder.
* Author: Patrick Kunka
* Copyright 2012-2013 Patrick Kunka, Barrel LLC, All Rights Reserved
*
* http://mixitup.io
*/

(function($){

	// DECLARE METHODS

	var methods = {

		// "INIT" METHOD

	    init: function(settings){

			return this.each(function(){

				/*var browser = window.navigator.appVersion.match(/Chrome\/(\d+)\./),
					ver = browser ? parseInt(browser[1], 10) : false,
					chromeFix = function(id){
						var grid = document.getElementById(id),
					        parent = grid.parentElement,
					        placeholder = document.createElement('div'),
					        frag = document.createDocumentFragment();

					    parent.insertBefore(placeholder, grid);
					    frag.appendChild(grid);
					    parent.replaceChild(grid, placeholder);
					    frag = null;
					    placeholder = null;
					};

				if(ver && ver == 31 || ver == 32){
					chromeFix(this.id);
				};*/

				// BUILD CONFIG OBJECT

				var config = {

					// PUBLIC PROPERTIES

					targetSelector : '.mix',
					filterSelector : '.filter',
					sortSelector : '.sort',
					buttonEvent: 'click',
					effects : ['fade', 'scale'],
					listEffects : null,
					easing : 'smooth',
					layoutMode: 'grid',
					targetDisplayGrid : 'inline-block',
					targetDisplayList: 'block',
					listClass : '',
					gridClass : '',
					transitionSpeed : 600,
					showOnLoad : 'all',
					sortOnLoad : false,
					multiFilter : false,
					filterLogic : 'or',
					resizeContainer : true,
					minHeight : 0,
					failClass : 'fail',
					perspectiveDistance : '3000',
					perspectiveOrigin : '50% 50%',
					animateGridList : true,
					onMixLoad: null,
					onMixStart : null,
					onMixEnd : null,

					// MISC

					container : null,
					origOrder : [],
					startOrder : [],
					newOrder : [],
					origSort: [],
					checkSort: [],
					filter : '',
					mixing : false,
					origDisplay : '',
					origLayout: '',
					origHeight : 0,
					newHeight : 0,
					isTouch : false,
					resetDelay : 0,
					failsafe : null,

					// CSS

					prefix : '',
					easingFallback : 'ease-in-out',
					transition : {},
					perspective : {},
					clean : {},
					fade : '1',
					scale : '',
					rotateX : '',
					rotateY : '',
					rotateZ : '',
					blur : '',
					grayscale : ''
				};

				if(settings){
					$.extend(config, settings);
				};

				// ADD CONFIG OBJECT TO CONTAINER OBJECT PER INSTANTIATION

				this.config = config;

				// DETECT TOUCH

				$.support.touch = 'ontouchend' in document;

				if ($.support.touch) {
					config.isTouch = true;
					config.resetDelay = 350;
				};

				// LOCALIZE CONTAINER

				config.container = $(this);
				var $cont = config.container;

				// GET VENDOR PREFIX

				config.prefix = prefix($cont[0]);
				config.prefix = config.prefix ? '-'+config.prefix.toLowerCase()+'-' : '';

				// CACHE 'DEFAULT' SORTING ORDER

				$cont.find(config.targetSelector).each(function(){
					config.origOrder.push($(this));
				});

				// PERFORM SORT ON LOAD

				if(config.sortOnLoad){
					var sortby, order;
					if($.isArray(config.sortOnLoad)){
						sortby = config.sortOnLoad[0], order = config.sortOnLoad[1];
						$(config.sortSelector+'[data-sort='+config.sortOnLoad[0]+'][data-order='+config.sortOnLoad[1]+']').addClass('active');
					} else {
						$(config.sortSelector+'[data-sort='+config.sortOnLoad+']').addClass('active');
						sortby = config.sortOnLoad, config.sortOnLoad = 'desc';
					};
					sort(sortby, order, $cont, config);
				};

				// BUILD TRANSITION AND PERSPECTIVE OBJECTS

				for(var i = 0; i<2; i++){
					var a = i==0 ? a = config.prefix : '';
					config.transition[a+'transition'] = 'all '+config.transitionSpeed+'ms ease-in-out';
					config.perspective[a+'perspective'] = config.perspectiveDistance+'px';
					config.perspective[a+'perspective-origin'] = config.perspectiveOrigin;
				};

				// BUILD TRANSITION CLEANER

				for(var i = 0; i<2; i++){
					var a = i==0 ? a = config.prefix : '';
					config.clean[a+'transition'] = 'none';
				};

				// CHOOSE GRID OR LIST

				if(config.layoutMode == 'list'){
					$cont.addClass(config.listClass);
					config.origDisplay = config.targetDisplayList;
				} else {
					$cont.addClass(config.gridClass);
					config.origDisplay = config.targetDisplayGrid;
				};
				config.origLayout = config.layoutMode;

				// PARSE 'SHOWONLOAD'

				var showOnLoadArray = config.showOnLoad.split(' ');

				// GIVE ACTIVE FILTER ACTIVE CLASS

				$.each(showOnLoadArray, function(){
					$(config.filterSelector+'[data-filter="'+this+'"]').addClass('active');
				});

				// RENAME "ALL" CATEGORY TO "MIX_ALL"

				$cont.find(config.targetSelector).addClass('mix_all');
				if(showOnLoadArray[0]  == 'all'){
					showOnLoadArray[0] = 'mix_all',
					config.showOnLoad = 'mix_all';
				};

				// FADE IN 'SHOWONLOAD'

				var $showOnLoad = $();
				$.each(showOnLoadArray, function(){
					$showOnLoad = $showOnLoad.add($('.'+this))
				});

				$showOnLoad.each(function(){
					var $t = $(this);
					if(config.layoutMode == 'list'){
						$t.css('display',config.targetDisplayList);
					} else {
						$t.css('display',config.targetDisplayGrid);
					};
					$t.css(config.transition);
				});

				// WRAP FADE-IN TO PREVENT RACE CONDITION

				var delay = setTimeout(function(){

					config.mixing = true;

					$showOnLoad.css('opacity','1');

					// CLEAN UP

					var reset = setTimeout(function(){
						if(config.layoutMode == 'list'){
							$showOnLoad.removeStyle(config.prefix+'transition, transition').css({
								display: config.targetDisplayList,
								opacity: 1
							});
						} else {
							$showOnLoad.removeStyle(config.prefix+'transition, transition').css({
								display: config.targetDisplayGrid,
								opacity: 1
							});
						};

						// FIRE "ONMIXLOAD" CALLBACK

						config.mixing = false;

						if(typeof config.onMixLoad == 'function') {
							var output = config.onMixLoad.call(this, config);

							// UPDATE CONFIG IF DATA RETURNED

							config = output ? output : config;
						};

					},config.transitionSpeed);
				},10);

				// PRESET ACTIVE FILTER

				config.filter = config.showOnLoad;

				// BIND SORT CLICK HANDLERS

				$(config.sortSelector).bind(config.buttonEvent,function(){

					if(!config.mixing){

						// PARSE SORT ARGUMENTS FROM BUTTON CLASSES

						var $t = $(this),
						sortby = $t.attr('data-sort'),
						order = $t.attr('data-order');

						if(!$t.hasClass('active')){
							$(config.sortSelector).removeClass('active');
							$t.addClass('active');
						} else {
							if(sortby != 'random')return false;
						};

						$cont.find(config.targetSelector).each(function(){
							config.startOrder.push($(this));
						});

						goMix(config.filter,sortby,order,$cont, config);

					};

				});

				// BIND FILTER CLICK HANDLERS

				$(config.filterSelector).bind(config.buttonEvent,function(){

					if(!config.mixing){

						var $t = $(this);

						// PARSE FILTER ARGUMENTS FROM BUTTON CLASSES

						if(config.multiFilter == false){

							// SINGLE ACTIVE BUTTON

							$(config.filterSelector).removeClass('active');
							$t.addClass('active');

							config.filter = $t.attr('data-filter');

							$(config.filterSelector+'[data-filter="'+config.filter+'"]').addClass('active');

						} else {

							// MULTIPLE ACTIVE BUTTONS

							var thisFilter = $t.attr('data-filter');

							if($t.hasClass('active')){
								$t.removeClass('active');

								// REMOVE FILTER FROM SPACE-SEPERATED STRING

								var re = new RegExp('(\\s|^)'+thisFilter);
								config.filter = config.filter.replace(re,'');
							} else {

								// ADD FILTER TO SPACE-SEPERATED STRING

								$t.addClass('active');
								config.filter = config.filter+' '+thisFilter;

							};
						};

						// GO MIX

						goMix(config.filter, null, null, $cont, config);

					};

				});

			});
		},

		// "TOGRID" METHOD

		toGrid: function(){
			return this.each(function(){
				var config = this.config;
				if(config.layoutMode != 'grid'){
					config.layoutMode = 'grid';
					goMix(config.filter, null, null, $(this), config);
				};
			});
		},

		// "TOLIST" METHOD

		toList: function(){
			return this.each(function(){
				var config = this.config;
				if(config.layoutMode != 'list'){
					config.layoutMode = 'list';
					goMix(config.filter, null, null, $(this), config);
				};
			});
		},

		// "FILTER" METHOD

		filter: function(arg){
			return this.each(function(){
				var config = this.config;
				if(!config.mixing){
					$(config.filterSelector).removeClass('active');
					$(config.filterSelector+'[data-filter="'+arg+'"]').addClass('active');
					goMix(arg, null, null, $(this), config);
				};
			});
		},

		// "SORT" METHOD

		sort: function(args){
			return this.each(function(){
				var config = this.config,
					$t = $(this);
				if(!config.mixing){
					$(config.sortSelector).removeClass('active');
					if($.isArray(args)){
						var sortby = args[0], order = args[1];
						$(config.sortSelector+'[data-sort="'+args[0]+'"][data-order="'+args[1]+'"]').addClass('active');
					} else {
						$(config.sortSelector+'[data-sort="'+args+'"]').addClass('active');
						var sortby = args, order = 'desc';
					};
					$t.find(config.targetSelector).each(function(){
						config.startOrder.push($(this));
					});

					goMix(config.filter,sortby,order, $t, config);

				};
			});
		},

		// "MULTIMIX" METHOD

		multimix: function(args){
			return this.each(function(){
				var config = this.config,
					$t = $(this);
					multiOut = {
						filter: config.filter,
						sort: null,
						order: 'desc',
						layoutMode: config.layoutMode
					};
				$.extend(multiOut, args);
				if(!config.mixing){
					$(config.filterSelector).add(config.sortSelector).removeClass('active');
					$(config.filterSelector+'[data-filter="'+multiOut.filter+'"]').addClass('active');
					if(typeof multiOut.sort !== 'undefined'){
						$(config.sortSelector+'[data-sort="'+multiOut.sort+'"][data-order="'+multiOut.order+'"]').addClass('active');
						$t.find(config.targetSelector).each(function(){
							config.startOrder.push($(this));
						});
					};
					config.layoutMode = multiOut.layoutMode;
					goMix(multiOut.filter,multiOut.sort,multiOut.order, $t, config);
				};
			});
		},

		// "REMIX" METHOD

		remix: function(arg){
			return this.each(function(){
				var config = this.config,
					$t = $(this);
				config.origOrder = [];
				$t.find(config.targetSelector).each(function(){
					var $th = $(this);
					$th.addClass('mix_all');
				    config.origOrder.push($th);
				});
				if(!config.mixing && typeof arg !== 'undefined'){
					$(config.filterSelector).removeClass('active');
					$(config.filterSelector+'[data-filter="'+arg+'"]').addClass('active');
					goMix(arg, null, null, $t, config);
				};
			});
		}
	};

	// DECLARE PLUGIN

	$.fn.mixitup = function(method, arg){
		if (methods[method]) {
			return methods[method].apply( this, Array.prototype.slice.call(arguments,1));
		} else if (typeof method === 'object' || ! method){
			return methods.init.apply( this, arguments );
		};
	};

	/* ==== THE MAGIC ==== */

	function goMix(filter, sortby, order, $cont, config){

		// WE ARE NOW MIXING

		clearInterval(config.failsafe);
		config.mixing = true;

		// APPLY ARGS TO CONFIG

		config.filter = filter;

		// FIRE "ONMIXSTART" CALLBACK

		if(typeof config.onMixStart == 'function') {
			var output = config.onMixStart.call(this, config);

			// UPDATE CONFIG IF DATA RETURNED

			config = output ? output : config;
		};

		// SHORT LOCAL VARS

		var speed = config.transitionSpeed;

		// REBUILD TRANSITION AND PERSPECTIVE OBJECTS

		for(var i = 0; i<2; i++){
			var a = i==0 ? a = config.prefix : '';
			config.transition[a+'transition'] = 'all '+speed+'ms linear';
			config.transition[a+'transform'] = a+'translate3d(0,0,0)';
			config.perspective[a+'perspective'] = config.perspectiveDistance+'px';
			config.perspective[a+'perspective-origin'] = config.perspectiveOrigin;
		};

		// CACHE TARGET ELEMENTS FOR QUICK ACCESS

		var mixSelector = config.targetSelector,
		$targets = $cont.find(mixSelector);

		// ADD DATA OBJECT TO EACH TARGET

		$targets.each(function(){
			this.data = {};
		});

		// RE-DEFINE CONTAINER INCASE NOT IMMEDIATE PARENT OF TARGET ELEMENTS

		var $par = $targets.parent();

		// ADD PERSPECTIVE TO CONTAINER

		$par.css(config.perspective);

		// SETUP EASING

		config.easingFallback = 'ease-in-out';
		if(config.easing == 'smooth')config.easing = 'cubic-bezier(0.25, 0.46, 0.45, 0.94)';
		if(config.easing == 'snap')config.easing = 'cubic-bezier(0.77, 0, 0.175, 1)';
		if(config.easing == 'windback'){
			config.easing = 'cubic-bezier(0.175, 0.885, 0.320, 1.275)',
			config.easingFallback = 'cubic-bezier(0.175, 0.885, 0.320, 1)'; // Fall-back for old webkit, with no values > 1 or < 1
		};
		if(config.easing == 'windup'){
			config.easing = 'cubic-bezier(0.6, -0.28, 0.735, 0.045)',
			config.easingFallback = 'cubic-bezier(0.6, 0.28, 0.735, 0.045)';
		};

		// USE LIST SPECIFIC EFFECTS IF DECLARED

		var effectsOut = config.layoutMode == 'list' && config.listEffects != null ? config.listEffects : config.effects;

		// BUILD EFFECTS STRINGS & SKIP IF IE8

		if (Array.prototype.indexOf){
			config.fade = effectsOut.indexOf('fade') > -1 ? '0' : '';
			config.scale = effectsOut.indexOf('scale') > -1 ? 'scale(.01)' : '';
			config.rotateZ = effectsOut.indexOf('rotateZ') > -1 ? 'rotate(180deg)' : '';
			config.rotateY = effectsOut.indexOf('rotateY') > -1 ? 'rotateY(90deg)' : '';
			config.rotateX = effectsOut.indexOf('rotateX') > -1 ? 'rotateX(90deg)' : '';
			config.blur = effectsOut.indexOf('blur') > -1 ? 'blur(8px)' : '';
			config.grayscale = effectsOut.indexOf('grayscale') > -1 ? 'grayscale(100%)' : '';
		};

		// DECLARE NEW JQUERY OBJECTS FOR GROUPING

		var $show = $(),
		$hide = $(),
		filterArray = [],
		multiDimensional = false;

		// BUILD FILTER ARRAY(S)

		if(typeof filter === 'string'){

			// SINGLE DIMENSIONAL FILTERING

			filterArray = buildFilterArray(filter);

		} else {

			// MULTI DIMENSIONAL FILTERING

			multiDimensional = true;

			$.each(filter,function(i){
				filterArray[i] = buildFilterArray(this);
			});
		};

		// "OR" LOGIC (DEFAULT)

		if(config.filterLogic == 'or'){

			if(filterArray[0] == '') filterArray.shift(); // IF FIRST ITEM IN ARRAY IS AN EMPTY SPACE, DELETE

			// IF NO ELEMENTS ARE DESIRED THEN HIDE ALL VISIBLE ELEMENTS

			if(filterArray.length < 1){

				$hide = $hide.add($cont.find(mixSelector+':visible'));

			} else {

			// ELSE CHECK EACH TARGET ELEMENT FOR ANY FILTER CATEGORY:

				$targets.each(function(){
					var $t = $(this);
					if(!multiDimensional){
						// IF HAS ANY FILTER, ADD TO "SHOW" OBJECT
						if($t.is('.'+filterArray.join(', .'))){
							$show = $show.add($t);
						// ELSE IF HAS NO FILTERS, ADD TO "HIDE" OBJECT
						} else {
							$hide = $hide.add($t);
						};
					} else {

						var pass = 0;
						// FOR EACH DIMENSION

						$.each(filterArray,function(i){
							if(this.length){
								if($t.is('.'+this.join(', .'))){
									pass++
								};
							} else if(pass > 0){
								pass++;
							};
						});
						// IF PASSES ALL DIMENSIONS, SHOW
						if(pass == filterArray.length){
							$show = $show.add($t);
						// ELSE HIDE
						} else {
							$hide = $hide.add($t);
						};
					};
				});

			};

		} else {

		// "AND" LOGIC

			// ADD "MIX_SHOW" CLASS TO ELEMENTS THAT HAVE ALL FILTERS

			$show = $show.add($par.find(mixSelector+'.'+filterArray.join('.')));

			// ADD "MIX_HIDE" CLASS TO EVERYTHING ELSE

			$hide = $hide.add($par.find(mixSelector+':not(.'+filterArray.join('.')+'):visible'));
		};

		// GET TOTAL NUMBER OF ELEMENTS TO SHOW

		var total = $show.length;

		// DECLARE NEW JQUERY OBJECTS

		var $tohide = $(),
		$toshow = $(),
		$pre = $();

		// FOR ELEMENTS TO BE HIDDEN, IF NOT ALREADY HIDDEN THEN ADD TO OBJECTS "TOHIDE" AND "PRE"
		// TO INDICATE PRE-EXISTING ELEMENTS TO BE HIDDEN

		$hide.each(function(){
			var $t = $(this);
			if($t.css('display') != 'none'){
				$tohide = $tohide.add($t);
				$pre = $pre.add($t);
			};
		});

		// IF ALL ELEMENTS ARE ALREADY SHOWN AND THERE IS NOTHING TO HIDE, AND NOT PERFORMING A LAYOUT CHANGE OR SORT:

		if($show.filter(':visible').length == total && !$tohide.length && !sortby){

			if(config.origLayout == config.layoutMode){

				// THEN CLEAN UP AND GO HOME

				resetFilter();
				return false;
			} else {

				// IF ONLY ONE ITEM AND CHANGING FORM GRID TO LIST, MOST LIKELY POSITION WILL NOT CHANGE SO WE'RE DONE

				if($show.length == 1){

					if(config.layoutMode == 'list'){
						$cont.addClass(config.listClass);
						$cont.removeClass(config.gridClass);
						$pre.css('display',config.targetDisplayList);
					} else {
						$cont.addClass(config.gridClass);
						$cont.removeClass(config.listClass);
						$pre.css('display',config.targetDisplayGrid);
					};

					// THEN CLEAN UP AND GO HOME

					resetFilter();
					return false;
				}
			};
		};

		// GET CONTAINER'S STARTING HEIGHT

		config.origHeight = $par.height();

		// IF THERE IS SOMETHING TO BE SHOWN:

		if($show.length){

			// REMOVE "FAIL CLASS" FROM CONTAINER IF EXISTS

			$cont.removeClass(config.failClass);


			// FOR ELEMENTS TO BE SHOWN, IF NOT ALREADY SHOWN THEN ADD TO OBJECTS "TOSHOW" ELSE ADD CLASS "MIX_PRE"
			// TO INDICATE PRE-EXISTING ELEMENT

			$show.each(function(){
				var $t = $(this);
				if($t.css('display') == 'none'){
					$toshow = $toshow.add($t)
				} else {
					$pre = $pre.add($t);
				};
			});

			// IF NON-ANIMATED LAYOUT MODE TRANSITION:

			if((config.origLayout != config.layoutMode) && config.animateGridList == false){

				// ADD NEW DISPLAY TYPES, CLEAN UP AND GO HOME

				if(config.layoutMode == 'list'){
					$cont.addClass(config.listClass);
					$cont.removeClass(config.gridClass);
					$pre.css('display',config.targetDisplayList);
				} else {
					$cont.addClass(config.gridClass);
					$cont.removeClass(config.listClass);
					$pre.css('display',config.targetDisplayGrid);
				};

				resetFilter();
				return false;
			};

			// IF IE, FUCK OFF, AND THEN CLEAN UP AND GO HOME

			if(!window.atob){
				resetFilter();
				return false;
			};

			// OVERRIDE ANY EXISTING TRANSITION TIMING FOR CALCULATIONS

			$targets.css(config.clean);

			// FOR EACH PRE-EXISTING ELEMENT, ADD STARTING POSITION TO 'ORIGPOS' ARRAY

			$pre.each(function(){
				this.data.origPos = $(this).offset();
			});

			// TEMPORARILY SHOW ALL ELEMENTS TO SHOW (THAT ARE NOT ALREADY SHOWN), WITHOUT HIDING ELEMENTS TO HIDE
			// AND ADD/REMOVE GRID AND LIST CLASSES FROM CONTAINER

			if(config.layoutMode == 'list'){
				$cont.addClass(config.listClass);
				$cont.removeClass(config.gridClass);
				$toshow.css('display',config.targetDisplayList);
			} else {
				$cont.addClass(config.gridClass);
				$cont.removeClass(config.listClass);
				$toshow.css('display',config.targetDisplayGrid);
			};

			// FOR EACH ELEMENT NOW SHOWN, ADD ITS INTERMEDIATE POSITION TO 'SHOWINTERPOS' ARRAY

			$toshow.each(function(){
				this.data.showInterPos = $(this).offset();
			});

			// FOR EACH ELEMENT TO BE HIDDEN, BUT NOT YET HIDDEN, AND NOW MOVED DUE TO SHOWN ELEMENTS,
			// ADD ITS INTERMEDIATE POSITION TO 'HIDEINTERPOS' ARRAY

			$tohide.each(function(){
				this.data.hideInterPos = $(this).offset();
			});

			// FOR EACH PRE-EXISTING ELEMENT, NOW MOVED DUE TO SHOWN ELEMENTS, ADD ITS POSITION TO 'PREINTERPOS' ARRAY

			$pre.each(function(){
				this.data.preInterPos = $(this).offset();
			});

			// SET DISPLAY PROPERTY OF PRE-EXISTING ELEMENTS INCASE WE ARE CHANGING LAYOUT MODE

			if(config.layoutMode == 'list'){
				$pre.css('display',config.targetDisplayList);
			} else {
				$pre.css('display',config.targetDisplayGrid);
			};

			// IF A SORT ARGUMENT HAS BEEN SENT, RUN SORT FUNCTION SO OBJECTS WILL MOVE TO THEIR FINAL ORDER

			if(sortby){
				sort(sortby, order, $cont, config);
			};

			// IF VISIBLE SORT ORDER IS THE SAME (WHICH WOULD NOT TRIGGER A TRANSITION EVENT)

			if(sortby && compareArr(config.origSort, config.checkSort)){

				// THEN CLEAN UP AND GO HOME
				resetFilter();
				return false;
			};

			// TEMPORARILY HIDE ALL SHOWN ELEMENTS TO HIDE

			$tohide.hide();

			// FOR EACH ELEMENT TO SHOW, AND NOW MOVED DUE TO HIDDEN ELEMENTS BEING REMOVED,
			// ADD ITS POSITION TO 'FINALPOS' ARRAY

			$toshow.each(function(i){
				this.data.finalPos = $(this).offset();
			});

			// FOR EACH PRE-EXISTING ELEMENT NOW MOVED DUE TO HIDDEN ELEMENTS BEING REMOVED,
			// ADD ITS POSITION TO 'FINALPREPOS' ARRAY

			$pre.each(function(){
				this.data.finalPrePos = $(this).offset();
			});

			// SINCE WE ARE IN OUT FINAL STATE, GET NEW HEIGHT OF CONTAINER

			config.newHeight = $par.height();

			// IF A SORT ARGUMENT AS BEEN SENT, RUN SORT FUNCTION 'RESET' TO MOVE ELEMENTS BACK TO THEIR STARTING ORDER

			if(sortby){
				sort('reset', null, $cont, config);
			};

			// RE-HIDE ALL ELEMENTS TEMPORARILY SHOWN

			$toshow.hide();

			// SET DISPLAY PROPERTY OF PRE-EXISTING ELEMENTS BACK TO THEIR
			// ORIGINAL PROPERTY, INCASE WE ARE CHANGING LAYOUT MODE

			$pre.css('display',config.origDisplay);

			// ADD/REMOVE GRID AND LIST CLASSES FROM CONTAINER

			if(config.origDisplay == 'block'){
				$cont.addClass(config.listClass);
				$toshow.css('display', config.targetDisplayList);
			} else {
				$cont.removeClass(config.listClass);
				$toshow.css('display', config.targetDisplayGrid);
			};

			// IF WE ARE ANIMATING CONTAINER, RESET IT TO ITS STARTING HEIGHT

			if(config.resizeContainer)$par.css('height', config.origHeight+'px');

			// ADD TRANSFORMS TO ALL ELEMENTS TO SHOW

			var toShowCSS = {};

			for(var i = 0; i<2; i++){
				var a = i==0 ? a = config.prefix : '';
				toShowCSS[a+'transform'] = config.scale+' '+config.rotateX+' '+config.rotateY+' '+config.rotateZ;
				toShowCSS[a+'filter'] = config.blur+' '+config.grayscale;
			};

			$toshow.css(toShowCSS);

			// FOR EACH PRE-EXISTING ELEMENT, SUBTRACT ITS INTERMEDIATE POSITION FROM ITS ORIGINAL POSITION
			// TO GET ITS STARTING OFFSET

			$pre.each(function(){
				var data = this.data,
				$t = $(this);

				if ($t.hasClass('mix_tohide')){
					data.preTX = data.origPos.left - data.hideInterPos.left;
					data.preTY = data.origPos.top - data.hideInterPos.top;
				} else {
					data.preTX = data.origPos.left - data.preInterPos.left;
					data.preTY = data.origPos.top - data.preInterPos.top;
				};
				var preCSS = {};
				for(var i = 0; i<2; i++){
					var a = i==0 ? a = config.prefix : '';
					preCSS[a+'transform'] = 'translate('+data.preTX+'px,'+data.preTY+'px)';
				};

				$t.css(preCSS);
			});

			// ADD/REMOVE GRID AND LIST CLASSES FROM CONTAINER

			if(config.layoutMode == 'list'){
				$cont.addClass(config.listClass);
				$cont.removeClass(config.gridClass);
			} else {
				$cont.addClass(config.gridClass);
				$cont.removeClass(config.listClass);
			};

			// WRAP ANIMATION FUNCTIONS IN 10ms TIMEOUT TO PREVENT RACE CONDITION

			var delay = setTimeout(function(){

				// APPLY TRANSITION TIMING TO CONTAINER, AND BEGIN ANIMATION TO NEW HEIGHT

				if(config.resizeContainer){
					var containerCSS = {};
					for(var i = 0; i<2; i++){
						var a = i==0 ? a = config.prefix : '';
						containerCSS[a+'transition'] = 'all '+speed+'ms ease-in-out';
						containerCSS['height'] = config.newHeight+'px';
					};
					$par.css(containerCSS);
				};

				// BEGIN FADING IN/OUT OF ALL ELEMENTS TO SHOW/HIDE
				$tohide.css('opacity',config.fade);
				$toshow.css('opacity',1);

				// FOR EACH ELEMENT BEING SHOWN, CALCULATE ITS TRAJECTORY BY SUBTRACTING
				// ITS INTERMEDIATE POSITION FROM ITS FINAL POSITION.
				// ALSO ADD SPEED AND EASING

				$toshow.each(function(){
					var data = this.data;
					data.tX = data.finalPos.left - data.showInterPos.left;
					data.tY = data.finalPos.top - data.showInterPos.top;

					var toShowCSS = {};
					for(var i = 0; i<2; i++){
						var a = i==0 ? a = config.prefix : '';
						toShowCSS[a+'transition-property'] = a+'transform, '+a+'filter, opacity';
						toShowCSS[a+'transition-timing-function'] = config.easing+', linear, linear';
						toShowCSS[a+'transition-duration'] = speed+'ms';
						toShowCSS[a+'transition-delay'] = '0';
						toShowCSS[a+'transform'] = 'translate('+data.tX+'px,'+data.tY+'px)';
						toShowCSS[a+'filter'] = 'none';
					};

					$(this).css('-webkit-transition', 'all '+speed+'ms '+config.easingFallback).css(toShowCSS);
				});

				// FOR EACH PRE-EXISTING ELEMENT, IF IT HAS A FINAL POSITION, CALCULATE
				// ITS TRAJETORY BY SUBTRACTING ITS INTERMEDIATE POSITION FROM ITS FINAL POSITION.
				// ALSO ADD SPEED AND EASING

				$pre.each(function(){
					var data = this.data
					data.tX = data.finalPrePos.left != 0 ? data.finalPrePos.left - data.preInterPos.left : 0;
					data.tY = data.finalPrePos.left != 0 ? data.finalPrePos.top - data.preInterPos.top : 0;

					var preCSS = {};
					for(var i = 0; i<2; i++){
						var a = i==0 ? a = config.prefix : '';
						preCSS[a+'transition'] = 'all '+speed+'ms '+config.easing;
						preCSS[a+'transform'] = 'translate('+data.tX+'px,'+data.tY+'px)';
					};

					$(this).css('-webkit-transition', 'all '+speed+'ms '+config.easingFallback).css(preCSS);
				});

				// BEGIN TRANSFORMS ON ALL ELEMENTS TO BE HIDDEN

				var toHideCSS = {};
				for(var i = 0; i<2; i++){
					var a = i==0 ? a = config.prefix : '';
					toHideCSS[a+'transition'] = 'all '+speed+'ms '+config.easing+', '+a+'filter '+speed+'ms linear, opacity '+speed+'ms linear';
					toHideCSS[a+'transform'] = config.scale+' '+config.rotateX+' '+config.rotateY+' '+config.rotateZ;
					toHideCSS[a+'filter'] = config.blur+' '+config.grayscale;
					toHideCSS['opacity'] = config.fade;
				};

				$tohide.css(toHideCSS);

				// ALL ANIMATIONS HAVE NOW BEEN STARTED, NOW LISTEN FOR TRANSITION END:

				$par.bind('webkitTransitionEnd transitionend otransitionend oTransitionEnd',function(e){

					if (e.originalEvent.propertyName.indexOf('transform') > -1 || e.originalEvent.propertyName.indexOf('opacity') > -1){

						if(mixSelector.indexOf('.') > -1){

						// IF MIXSELECTOR IS A CLASS NAME

							if($(e.target).hasClass(mixSelector.replace('.',''))){
								resetFilter();
							};

						} else {

						// IF MIXSELECTOR IS A TAG

							if($(e.target).is(mixSelector)){
								resetFilter();
							};

						};

					};
				});

			},10);

			// LAST RESORT EMERGENCY FAILSAFE

			config.failsafe = setTimeout(function(){
				if(config.mixing){
					resetFilter();
				};
			}, speed + 400);

		} else {

		// ELSE IF NOTHING TO SHOW, AND EVERYTHING TO BE HIDDEN

			// IF WE ARE RESIZING CONTAINER, SET ITS STARTING HEIGHT

			if(config.resizeContainer)$par.css('height', config.origHeight+'px');

			// IF IE, FUCK OFF, AND THEN GO HOME

			if(!window.atob){
				resetFilter();
				return false;
			};

			// GROUP ALL ELEMENTS TO HIDE INTO JQUERY OBJECT

			$tohide = $hide;

			// WRAP ANIMATION FUNCTIONS IN A 10ms DELAY TO PREVENT RACE CONDITION

			var delay = setTimeout(function(){

				// APPLY PERSPECTIVE TO CONTAINER

				$par.css(config.perspective);

				// APPLY TRANSITION TIMING TO CONTAINER, AND BEGIN ANIMATION TO NEW HEIGHT

				if(config.resizeContainer){
					var containerCSS = {};
					for(var i = 0; i<2; i++){
						var a = i==0 ? a = config.prefix : '';
						containerCSS[a+'transition'] = 'height '+speed+'ms ease-in-out';
						containerCSS['height'] = config.minHeight+'px';
					};
					$par.css(containerCSS);
				};

				// APPLY TRANSITION TIMING TO ALL TARGET ELEMENTS

				$targets.css(config.transition);

				// GET TOTAL NUMBER OF ELEMENTS TO HIDE

				var totalHide = $hide.length;

				// IF SOMETHING TO HIDE:

				if(totalHide){

					// BEGIN TRANSFORMS ON ALL ELEMENTS TO BE HIDDEN

					var toHideCSS = {};
					for(var i = 0; i<2; i++){
						var a = i==0 ? a = config.prefix : '';
						toHideCSS[a+'transform'] = config.scale+' '+config.rotateX+' '+config.rotateY+' '+config.rotateZ;
						toHideCSS[a+'filter'] = config.blur+' '+config.grayscale;
						toHideCSS['opacity'] = config.fade;
					};

					$tohide.css(toHideCSS);

					// ALL ANIMATIONS HAVE NOW BEEN STARTED, NOW LISTEN FOR TRANSITION END:

					$par.bind('webkitTransitionEnd transitionend otransitionend oTransitionEnd',function(e){
						if (e.originalEvent.propertyName.indexOf('transform') > -1 || e.originalEvent.propertyName.indexOf('opacity') > -1){
							$cont.addClass(config.failClass);
							resetFilter();
						};
					});

				} else {

				// ELSE, WE'RE DONE MIXING

					config.mixing = false;
				};

			}, 10);
		};

		// CLEAN UP AND RESET FUNCTION

		function resetFilter(){

			// UNBIND TRANSITION END EVENTS FROM CONTAINER

			$par.unbind('webkitTransitionEnd transitionend otransitionend oTransitionEnd');

			// IF A SORT ARGUMENT HAS BEEN SENT, SORT ELEMENTS TO THEIR FINAL ORDER

			if(sortby){
				sort(sortby, order, $cont, config);
			};

			// EMPTY SORTING ARRAYS

			config.startOrder = [], config.newOrder = [], config.origSort = [], config.checkSort = [];

			// REMOVE INLINE STYLES FROM ALL TARGET ELEMENTS AND SLAM THE BRAKES ON

			$targets.removeStyle(
				config.prefix+'filter, filter, '+config.prefix+'transform, transform, opacity, display'
			).css(config.clean).removeAttr('data-checksum');

			// BECAUSE IE SUCKS

			if(!window.atob){
				$targets.css({
					display: 'none',
					opacity: '0'
				});
			};

			// REMOVE HEIGHT FROM CONTAINER ONLY IF RESIZING

			var remH = config.resizeContainer ? 'height' : '';

			// REMOVE INLINE STYLES FROM CONTAINER

			$par.removeStyle(
				config.prefix+'transition, transition, '+config.prefix+'perspective, perspective, '+config.prefix+'perspective-origin, perspective-origin, '+remH
			);

			// ADD FINAL DISPLAY PROPERTIES AND OPACITY TO ALL SHOWN ELEMENTS
			// CACHE CURRENT LAYOUT MODE & SORT FOR NEXT MIX

			if(config.layoutMode == 'list'){
				$show.css({display:config.targetDisplayList, opacity:'1'});
				config.origDisplay = config.targetDisplayList;
			} else {
				$show.css({display:config.targetDisplayGrid, opacity:'1'});
				config.origDisplay = config.targetDisplayGrid;
			};
			config.origLayout = config.layoutMode;

			var wait = setTimeout(function(){

				// LET GO OF THE BRAKES

				$targets.removeStyle(config.prefix+'transition, transition');

				// WE'RE DONE MIXING

				config.mixing = false;

				// FIRE "ONMIXEND" CALLBACK

				if(typeof config.onMixEnd == 'function') {
					var output = config.onMixEnd.call(this, config);

					// UPDATE CONFIG IF DATA RETURNED

					config = output ? output : config;
				};
			});
		};
	};

	// SORT FUNCTION

	function sort(sortby, order, $cont, config){

		// COMPARE BY ATTRIBUTE

		function compare(a,b) {
			var sortAttrA = isNaN(a.attr(sortby) * 1) ? a.attr(sortby).toLowerCase() : a.attr(sortby) * 1,
				sortAttrB = isNaN(b.attr(sortby) * 1) ? b.attr(sortby).toLowerCase() : b.attr(sortby) * 1;
		  	if (sortAttrA < sortAttrB)
		    	return -1;
		  	if (sortAttrA > sortAttrB)
		    	return 1;
		  	return 0;
		};

		// REBUILD DOM

		function rebuild(element){
			if(order == 'asc'){
				$sortWrapper.prepend(element).prepend(' ');
			} else {
				$sortWrapper.append(element).append(' ');
			};
		};

		// RANDOMIZE ARRAY

		function arrayShuffle(oldArray){
			var newArray = oldArray.slice();
		 	var len = newArray.length;
			var i = len;
			while (i--){
			 	var p = parseInt(Math.random()*len);
				var t = newArray[i];
		  		newArray[i] = newArray[p];
			  	newArray[p] = t;
		 	};
			return newArray;
		};

		// SORT

		$cont.find(config.targetSelector).wrapAll('<div class="mix_sorter"/>');

		var $sortWrapper = $cont.find('.mix_sorter');

		if(!config.origSort.length){
			$sortWrapper.find(config.targetSelector+':visible').each(function(){
				$(this).wrap('<s/>');
				config.origSort.push($(this).parent().html().replace(/\s+/g, ''));
				$(this).unwrap();
			});
		};



		$sortWrapper.empty();

		if(sortby == 'reset'){
			$.each(config.startOrder,function(){
				$sortWrapper.append(this).append(' ');
			});
		} else if(sortby == 'default'){
			$.each(config.origOrder,function(){
				rebuild(this);
			});
		} else if(sortby == 'random'){
			if(!config.newOrder.length){
				config.newOrder = arrayShuffle(config.startOrder);
			};
			$.each(config.newOrder,function(){
				$sortWrapper.append(this).append(' ');
			});
		} else if(sortby == 'custom'){
			$.each(order, function(){
				rebuild(this);
			});
		} else {
			// SORT BY ATTRIBUTE

			if(typeof config.origOrder[0].attr(sortby) === 'undefined'){
				console.log('No such attribute found. Terminating');
				return false;
			};

			if(!config.newOrder.length){
				$.each(config.origOrder,function(){
					config.newOrder.push($(this));
				});
				config.newOrder.sort(compare);
			};
			$.each(config.newOrder,function(){
				rebuild(this);
			});

		};
		config.checkSort = [];
		$sortWrapper.find(config.targetSelector+':visible').each(function(i){
			var $t = $(this);
			if(i == 0){

				// PREVENT COMPARE RETURNING FALSE POSITIVES ON ELEMENTS WITH NO CLASS/ATTRIBUTES

				$t.attr('data-checksum','1');
			};
			$t.wrap('<s/>');
			config.checkSort.push($t.parent().html().replace(/\s+/g, ''));
			$t.unwrap();
		});

		$cont.find(config.targetSelector).unwrap();
	};

	// FIND VENDOR PREFIX

	function prefix(el) {
	    var prefixes = ["Webkit", "Moz", "O", "ms"];
	    for (var i = 0; i < prefixes.length; i++){
	        if (prefixes[i] + "Transition" in el.style){
	            return prefixes[i];
	        };
	    };
	    return "transition" in el.style ? "" : false;
	};

	// REMOVE SPECIFIC STYLES

	$.fn.removeStyle = function(style){
		return this.each(function(){
			var obj = $(this);
			style = style.replace(/\s+/g, '');
			var styles = style.split(',');
			$.each(styles,function(){

				var search = new RegExp(this.toString() + '[^;]+;?', 'g');
				obj.attr('style', function(i, style){
					if(style) return style.replace(search, '');
			    });
			});
		});
    };

	// COMPARE ARRAYS

	function compareArr(a,b){
	    if (a.length != b.length) return false;
	    for (var i = 0; i < b.length; i++){
	        if (a[i].compare) {
	            if (!a[i].compare(b[i])) return false;
	        };
	        if (a[i] !== b[i]) return false;
	    };
	    return true;
	};

	// BUILD FILTER ARRAY(S)

	function buildFilterArray(str){
		// CLEAN FILTER STRING
		str = str.replace(/\s{2,}/g, ' ');
		// FOR EACH PEROID SEPERATED CLASS NAME, ADD STRING TO FILTER ARRAY
		var arr = str.split(' ');
		// IF ALL, REPLACE WITH MIX_ALL
		$.each(arr,function(i){
			if(this == 'all')arr[i] = 'mix_all';
		});
		if(arr[0] == "")arr.shift();
		return arr;
	};


})(jQuery);
